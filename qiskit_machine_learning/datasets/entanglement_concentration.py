# This code is part of a Qiskit project.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""
Entanglement Concentration
"""
from __future__ import annotations

import warnings

import numpy as np
import os

from qiskit import QuantumCircuit
from qiskit.quantum_info import Operator, Statevector
from qiskit.circuit import ParameterVector

from ..utils import algorithm_globals


# pylint: disable=too-many-positional-arguments
def entanglement_concentration_data(
    training_size: int,
    test_size: int,
    n: int,
    mode: str = "easy",
    one_hot: bool = True,
    include_sample_total: bool = False,
    sampling_method: str = "isotropic",
    class_labels: list | None = None,
) -> (
    tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]
    | tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]
):
    r"""
    Generates a dataset that comprises of Quantum States with two different
    amounts of Concentration Of Entanglement (CE) and their corresponding class labels.
    These states are generated by the effect of two different pre-trained ansatz
    on fully seperable input states according to the procedure outlined in [1]. Pre-trained
    data in courtesy of L Schatzki et el [3]. The datapoints can be fully separated using
    the SWAP test outlined in [2]. First, input states are randomly generated from a
    uniform distribution, using a sampling method determined by the ``sampling_method``
    argument. Next, based on the ``mode`` argument, two pre-trained circuits "A" and "B"
    are used for generating datapoints.

    CE can be interpreted as a measure of correlation between the different qubits.
    The ``mode`` argument supports two options. ``"easy"`` gives datapoints with high CE
    difference hence being easy to seperate. ``"hard"`` mode gives closer CE values.
    The user's classifiers can be benchmarked against these modes for their ability to
    separate the data into two classes based on CE.

    Current implementation supports only ``n`` values of 3, 4 and 8.

    ``sampling_method`` argument supports two options. ``"isotropic"`` and ``"cardinal"``.
    Isotropic generates qubit states that are sampled randomly in the Bloch Sphere and takes the
    tensor product of all the qubits to build the input state. Cardinal generates only states
    that fall on the axes of the Bloch Sphere before taking the tensor product.

    **References:**

    [1] Schatzki L, Arrasmith A, Coles PJ, Cerezo M. Entangled datasets for quantum machine learning.
    arXiv preprint. 2021 Sep;2109.03400. arXiv:2109.03400
    <https://arxiv.org/abs/2109.03400>_

    [2] Beckey JL, Gigena N, Coles PJ, Cerezo M. Computable and operationally meaningful multipartite
    entanglement measures. Physical Review Letters. 2021 Sep 27;127(14):140501.
    DOI:10.1103/PhysRevLett.127.140501
    <https://doi.org/10.1103/PhysRevLett.127.140501>_

    [3] Schatzki L. NTangled Datasets – Hardware Efficient [dataset]. GitHub.
    2022 Mar 2 (commit f3a68ff). GitHub repository
    <https://github.com/LSchatzki/NTangled_Datasets/tree/main/Hardware_Efficient>_

    Parameters:
        training_size : Number of training samples per class.
        test_size :  Number of testing samples per class.
        n : Number of qubits (dimension of the feature space). Current implementation
            supports only 3, 4 and 8
        mode :
            Choices are:

                * ``"easy"``: uses CE values 0.05 and 0.35 for n = [3,4] and 0.10 and 0.45 for n = 8
                * ``"hard"``: uses CE values 0.15 and 0.25 for n = [3,4] and 0.15 and 0.25 for n = 8

            Default is ``"easy"``.
        one_hot : If True, returns labels in one-hot format. Default is True.
        include_sample_total : If True, the function also returns the total number
            of accepted samples. Default is False.
        sampling_method: The method used to generate input states.
            Choices are:

                * ``"isotropic"``: samples qubit states uniformly in the bloch sphere
                * ``"cardinal"``: samples qubit states out of the 6 axes of bloch sphere

            Default is ``"cardinal"``.
        class_labels : Custom labels for the two classes when one-hot is not enabled.
            If not provided, the labels default to ``0`` and ``+1``

    Returns:
        Tuple
        containing the following:

        * **training_features** : ``np.ndarray``
        * **training_labels** : ``np.ndarray``
        * **testing_features** : ``np.ndarray``
        * **testing_labels** : ``np.ndarray``

        If ``include_sample_total=True``, a fifth element (``np.ndarray``) is included
        that specifies the total number of accepted samples.
    """
    # Default Value
    if class_labels is None:
        class_labels = [0, 1]

    # Errors
    if training_size < 0:
        raise ValueError("Training size can't be less than 0")
    if test_size < 0:
        raise ValueError("Test size can't be less than 0")
    if n not in [3,4,8]:
        raise ValueError("Currently only 3, 4 and 8 qubits are supported")
    if mode not in {"easy", "hard"}:
        raise ValueError("Invalid mode. Must be 'easy' or 'hard'")
    if sampling_method not in {"isotropic", "cardinal"}:
        raise ValueError("Invalid sampling method. Must be 'isotropic' or 'cardinal'")

    n_points = training_size + test_size

    # Warnings
    if sampling_method == "cardinal" and n_points > 3**n:
        warnings.warn(
            """Cardinal Sampling for large number of samples is not recommended
            and can lead to repeating points. Try "isotropic" sampling method""",
            UserWarning,
        )

    # Depth Settings
    depth = {(3, "easy"): (2, 6), (3, "hard"): (3, 5),
             (4, "easy"): (2, 6), (4, "hard"): (3, 5),
             (8, "easy"): (6, 5), (8, "hard"): (5, 6)
            }


    d_low, d_high = depth[(n, mode)]

    # Import Models
    qc_low = QuantumCircuit(n)
    qc_high = QuantumCircuit(n)

    params_low = ParameterVector('low', d_low * n * 3)
    _hardware_efficient_ansatz(qc_low, params_low, n, d_low)
    bound_qc_low = _assign_parameters(n, mode, "low", d_low, qc_low)

    params_high = ParameterVector('high', d_high * n * 3)
    _hardware_efficient_ansatz(qc_high, params_high, n, d_high)
    bound_qc_high = _assign_parameters(n, mode, "high", d_high, qc_high)

    # Convert them to Unitaries for batch processing
    U_low = Operator(bound_qc_low)
    U_high = Operator(bound_qc_high)

    # Sampling Input States

    print(U_low, U_high)

    return (1,2,3,4)

def _assign_parameters(n_qubits, mode, label, depth, qc):
    """Loads parameters into the given QuantumCircuit"""
    file_path = "models/entanglement_"
    file_path += f"{mode}_" # easy / hard
    file_path += f"{label}_" # low / high
    file_path += f"{n_qubits}qubits.npy"

    file_path = _get_path(file_path)

    weights = np.load(file_path).flatten()

    if len(weights) != 3*depth*n_qubits:
        raise ValueError("""Parameter mismatch: please install the latest 
            version using 'pip install qiskit-machine-learning'""")

    qc = qc.assign_parameters(weights)

    return qc

def _hardware_efficient_ansatz(qc, params, n_qubits, depth):
    """Adds hardware-efficient ansatz to a QuantumCircuit"""
    param_idx = 0

    for _ in range(depth):
        
        for q in range(n_qubits):
            qc.rx(params[param_idx], q)
            qc.ry(params[param_idx+1], q)
            qc.rz(params[param_idx+2], q)
            param_idx += 3

        # Entangling layer
        for q in range(n_qubits - 1):
            qc.cx(q, q+1)
        if n_qubits > 1:
            qc.cx(n_qubits-1, 0)

def _get_path(filepath):
    root = os.path.dirname(__file__)
    path = root if filepath is None else os.path.join(root, filepath)
    return os.path.normpath(path)

entanglement_concentration_data(10,10,4)